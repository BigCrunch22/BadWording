using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using KModkit;
using System.Text.RegularExpressions;

public class BadWordingScript : MonoBehaviour
{
    public KMBombInfo Bomb;
    public KMAudio Audio;
    public KMBombModule Module;
    
    public KMSelectable[] Buttons;
    public TextMesh[] ButtonText;
    
    string[][] ManiaString = new string[][]{
        new string[] {"HIM’S", "THIS", "YOUR", "MY", "HER", "THAT", "HIS", "HER’S", "THEIR", "OUR"},
        new string[] {"PHRASE", "SENTENCE", "NUMBER", "MANUAL", "WIRE", "THING", "BUTTON", "WORD", "MODULE", "BOMB"},
        new string[] {"BEEN", "AM", "WERE", "DO", "AMN’T", "ARE", "WON’T", "IS", "WILL", "BE"},
        new string[] {"YES", "OK", "OFF", "ON", "OKAY", "UHHH", "NO", "HABERDASHERY", "OH", "DONE"},
        new string[] {"NOR", "THOUGH", "AS", "HOWEVER", "SINCE", "AND", "BECAUSE", "WHILE", "HOW", "BUT"},
        new string[] {"SMASH", "SOLVE", "THROW", "DIE", "YEET", "DEFUSE", "STOP", "CUT", "PRESS", "DETONATE"},
        new string[] {"BEEN", "AM", "WERE", "DO", "AMN’T", "ARE", "WON’T", "IS", "WILL", "BE"},
        new string[] {"BEEN", "AM", "WERE", "DO", "AMN’T", "ARE", "WON’T", "IS", "WILL", "BE"},
        new string[] {"OCCUR", "FORGET", "ABOUT", "DESTROY", "COMPLETE", "HAPPEN", "FINISH", "LOGIC", "SUCCEED", "TURN"}
    };
    
    int Additive = 0;
    
    //Logging
    static int moduleIdCounter = 1;
    int moduleId;
    private bool ModuleSolved;
    
    void Awake()
    {
        moduleId = moduleIdCounter++;
        for (int i = 0; i < Buttons.Length; i++)
        {
            int Press = i;
            Buttons[i].OnInteract += delegate ()
            {
                ButtonPress(Press);
                return false;
            };
        }
    }
    
    void ButtonPress(int Press)
    {
        Buttons[Press].AddInteractionPunch(0.2f);
        Audio.PlayGameSoundAtTransform(KMSoundOverride.SoundEffect.ButtonPress, transform);
        if (!ModuleSolved)
        {
            if ((Press + 1) == Additive)
            {
                Module.HandlePass();
                ModuleSolved = true;
                for (int x = 0; x < 9; x++)
                {
                    ButtonText[x].fontSize = 80;
                    ButtonText[x].text = "SOLVED";
                    ButtonText[x].color = new Color (0f/255f, 255f/255f, 0f/255f);
                }
				Audio.PlayGameSoundAtTransform(KMSoundOverride.SoundEffect.CorrectChime, transform);
				Debug.LogFormat("[Bad Wording #{0}] You pressed Button {1}. That was correct. Module solves.", moduleId, (Press + 1).ToString());
            }
            
            else
            {
                Module.HandleStrike();
                Additive = 0;
				Debug.LogFormat("[Bad Wording #{0}] You pressed Button {1}. That was incorrect. Module strikes.", moduleId, (Press + 1).ToString());
                GenerateAbsolutelyEverything();
            }
        }
    }
    
    void Start()
    {
        GenerateAbsolutelyEverything();
    }
    
    void GenerateAbsolutelyEverything()
    {
		string[] ColorChoices = {"Blue", "Purple", "Green", "Gray", "Yellow", "Magenta", "Black", "Red", "Orange", "Cyan"};
        int Color, Focus;
		string Megalomania = "The texts/colors generated by the module:  ";
        for (int x = 0; x < 9; x++)
        {
            Color = UnityEngine.Random.Range(0,10);
            Focus = UnityEngine.Random.Range(0,10);
            ButtonText[x].text = ManiaString[x][Focus];
			Megalomania += x != 8 ? ButtonText[x].text + "/" + ColorChoices[Color] + " - " : ButtonText[x].text + "/" + ColorChoices[Color];
            Additive += ((Color + 1) * (Focus + 1));            
            switch (ButtonText[x].text.Length)
            {
                case 12:
                    ButtonText[x].fontSize = 40;
                    break;
                case 8:
                case 7:
                    ButtonText[x].fontSize = 65;
                    break;
                case 6:
                    ButtonText[x].fontSize = 80;
                    break;
                default:
                    ButtonText[x].fontSize = 90;
                    break;
            }
            
            switch (Color)
            {
                case 0:
                    ButtonText[x].color = new Color (0f/255f, 0f/255f, 255f/255f);
                    break;
                case 1:
                    ButtonText[x].color = new Color (128f/255f, 0f/255f, 128f/255f);
                    break;
                case 2:
                    ButtonText[x].color = new Color (0f/255f, 255f/255f, 0f/255f);
                    break;
                case 3:
                    ButtonText[x].color = new Color (128f/255f, 128f/255f, 128f/255f);
                    break;
                case 4:
                    ButtonText[x].color = new Color (255f/255f, 255f/255f, 0f/255f);
                    break;
                case 5:
                    ButtonText[x].color = new Color (255f/255f, 0f/255f, 255f/255f);
                    break;
                case 6:
                    ButtonText[x].color = new Color (0f/255f, 0f/255f, 0f/255f);
                    break;
                case 7:
                    ButtonText[x].color = new Color (255f/255f, 0f/255f, 0f/255f);
                    break;
                case 8:
                    ButtonText[x].color = new Color (255f/255f, 165f/255f, 0f/255f);
                    break;
                case 9:
                    ButtonText[x].color = new Color (0f/255f, 255f/255f, 255f/255f);
                    break;
                default:
                    break;
            }
        }
        Debug.LogFormat("[Bad Wording #{0}] {1}.", moduleId, Megalomania);
		Debug.LogFormat("[Bad Wording #{0}] The total of all 9 displayed texts is {1}.", moduleId, Additive);
        while (Additive.ToString().Length != 1)
        {
            int Guide = 0;
            string Heckel = Additive.ToString();
            for (int y = 0; y < Heckel.Length; y++)
            {
                Guide += Int32.Parse(Heckel[y].ToString());
            }
            Additive = Guide;
        }
		
		Debug.LogFormat("[Bad Wording #{0}] The correct button to press is Button {1}.", moduleId, Additive);
    }
	
	//twitch plays
    #pragma warning disable 414
    private readonly string TwitchHelpMessage = @"To press the corresponding button position on the module, use the command !{0} press [1-9]";
    #pragma warning restore 414
	
	string[] ValidNumbers = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
    IEnumerator ProcessTwitchCommand(string command)
    {
		string[] parameters = command.Split(' ');
		if (parameters.Length != 2)
		{
			yield return "sendtochaterror Invalid parameter length. The command was not processed.";
			yield break;
		}
			
        if (Regex.IsMatch(parameters[0], @"^\s*press\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            yield return null;
			if (!parameters[1].EqualsAny(ValidNumbers))
			{
				yield return "sendtochaterror Invalid button position sent. The command was not processed.";
				yield break;
			}
			Buttons[Int32.Parse(parameters[1]) - 1].OnInteract();
        }
	}
}
